/**
 * Parser for .zshrc configuration files
 */

export interface VariableInfo {
  value: string
  suffix?: string  // Commands after && || or ;
  disabled?: boolean  // Whether the variable is disabled
}

export interface ZshConfig {
  environmentVariables: Record<string, VariableInfo | string>
  paths: string[]
  aliases: Record<string, VariableInfo | string>
  otherLines: string[]
}

// Program-generated comments that should not be preserved
const GENERATED_COMMENTS = [
  '# Zsh Configuration',
  '# Generated by Rei Config Manager',
  '# Environment Variables',
  '# PATH Configuration',
  '# Aliases',
  '# Other Configurations'
]

/**
 * Check if a line is a program-generated comment
 */
function isGeneratedComment(line: string): boolean {
  const trimmed = line.trim()
  return GENERATED_COMMENTS.includes(trimmed)
}

/**
 * Parse a .zshrc file content into structured data
 */
export function parseZshConfig(content: string): ZshConfig {
  const lines = content.split('\n')
  const config: ZshConfig = {
    environmentVariables: {},
    paths: [],
    aliases: {},
    otherLines: []
  }

  const existingPaths = new Set<string>()

  for (const line of lines) {
    const trimmedLine = line.trim()

    // Skip empty lines
    if (!trimmedLine) {
      continue
    }

    // Check for disabled variables with #[DISABLED] marker
    const disabledMatch = trimmedLine.match(/^#\[DISABLED\]\s+(.*)$/)
    if (disabledMatch) {
      const disabledContent = disabledMatch[1]
      // Process the disabled line as if it were enabled, but mark as disabled
      processLine(disabledContent, config, existingPaths, true)
      continue
    }

    // Store regular comments in otherLines to preserve them (but skip program-generated ones)
    if (trimmedLine.startsWith('#')) {
      if (!isGeneratedComment(trimmedLine)) {
        config.otherLines.push(line) // Use original line to preserve indentation
      }
      continue
    }

    // Process normal lines
    processLine(trimmedLine, config, existingPaths, false)
  }

  return config
}

// Helper function to check if command separators exist outside of quotes
function hasCommandSeparatorOutsideQuotes(line: string): boolean {
  let inSingleQuote = false
  let inDoubleQuote = false
  let escaped = false
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    const nextChar = line[i + 1]
    
    if (escaped) {
      escaped = false
      continue
    }
    
    if (char === '\\') {
      escaped = true
      continue
    }
    
    if (char === "'" && !inDoubleQuote) {
      inSingleQuote = !inSingleQuote
    } else if (char === '"' && !inSingleQuote) {
      inDoubleQuote = !inDoubleQuote
    } else if (!inSingleQuote && !inDoubleQuote) {
      // Check for separators only when outside quotes
      if (char === ';') return true
      if (char === '&' && nextChar === '&') return true
      if (char === '|' && nextChar === '|') return true
    }
  }
  
  return false
}

// Helper function to split line at command separator (outside quotes)
function splitAtSeparator(line: string): { main: string, suffix?: string } {
  let inSingleQuote = false
  let inDoubleQuote = false
  let escaped = false
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    const nextChar = line[i + 1]
    
    if (escaped) {
      escaped = false
      continue
    }
    
    if (char === '\\') {
      escaped = true
      continue
    }
    
    if (char === "'" && !inDoubleQuote) {
      inSingleQuote = !inSingleQuote
    } else if (char === '"' && !inSingleQuote) {
      inDoubleQuote = !inDoubleQuote
    } else if (!inSingleQuote && !inDoubleQuote) {
      // Found separator outside quotes
      if (char === ';' || 
          (char === '&' && nextChar === '&') || 
          (char === '|' && nextChar === '|')) {
        const separatorStart = i
        return {
          main: line.substring(0, separatorStart).trim(),
          suffix: line.substring(separatorStart)
        }
      }
    }
  }
  
  return { main: line }
}

// Helper function to process a line
function processLine(
  trimmedLine: string,
  config: ZshConfig,
  existingPaths: Set<string>,
  isDisabled: boolean = false
) {
  // Check if line contains command separators (outside of quotes)
  const hasCommandSeparator = hasCommandSeparatorOutsideQuotes(trimmedLine)
    
    // Parse export statements
    // Split at separator if present
    const { main: exportLine, suffix } = hasCommandSeparator 
      ? splitAtSeparator(trimmedLine)
      : { main: trimmedLine, suffix: undefined }
    
    const exportMatch = exportLine.match(/^export\s+([A-Z_][A-Z0-9_]*)=(.*)$/)
    if (exportMatch) {
      const [_fullMatch, key, value] = exportMatch
      const cleanValue = unquote(value.trim())
      
      // Special handling for PATH
      if (key === 'PATH') {
        // If PATH is disabled, save the whole line to otherLines instead of parsing
        if (isDisabled) {
          const disabledLine = `#[DISABLED] export ${key}="${cleanValue}"${suffix || ''}`
          config.otherLines.push(disabledLine)
          return
        }
        
        // Parse PATH additions
        const pathValue = cleanValue
        if (pathValue.includes('$PATH')) {
          // Extract new paths being added to PATH
          const parts = pathValue.split('$PATH')
          for (const part of parts) {
            const paths = part.split(':').filter(p => p && p !== '')
            for (const path of paths) {
              if (!existingPaths.has(path)) {
                config.paths.push(path)
                existingPaths.add(path)
              }
            }
          }
        } else {
          // Complete PATH override
          const paths = pathValue.split(':').filter(p => p)
          for (const path of paths) {
            if (!existingPaths.has(path)) {
              config.paths.push(path)
              existingPaths.add(path)
            }
          }
        }
      } else {
        // Store variable with suffix and disabled state if present
        config.environmentVariables[key] = (suffix || isDisabled)
          ? { value: cleanValue, ...(suffix && { suffix }), ...(isDisabled && { disabled: true }) }
          : cleanValue
      }
      return
    }

    // Parse alias statements
    // Split at separator if present (reuse the same split from export check)
    const aliasLine = hasCommandSeparator ? exportLine : trimmedLine
    const aliasSuffix = hasCommandSeparator ? suffix : undefined
    
    const aliasMatch = aliasLine.match(/^alias\s+([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$/)
    if (aliasMatch) {
      const [, name, value] = aliasMatch
      const cleanValue = unquote(value.trim())
      
      // Store alias with suffix and disabled state if present
      config.aliases[name] = (aliasSuffix || isDisabled)
        ? { value: cleanValue, ...(aliasSuffix && { suffix: aliasSuffix }), ...(isDisabled && { disabled: true }) }
        : cleanValue
      
      return
    }

    // Parse PATH additions without export
    const pathMatch = trimmedLine.match(/^PATH=(.*)$/)
    if (pathMatch) {
      // If PATH is disabled, save the whole line to otherLines instead of parsing
      if (isDisabled) {
        config.otherLines.push(`#[DISABLED] ${trimmedLine}`)
        return
      }
      
      const pathValue = unquote(pathMatch[1])
      if (pathValue.includes('$PATH')) {
        const parts = pathValue.split('$PATH')
        for (const part of parts) {
          const paths = part.split(':').filter(p => p && p !== '')
          for (const path of paths) {
            if (!existingPaths.has(path)) {
              config.paths.push(path)
              existingPaths.add(path)
            }
          }
        }
      }
      return
    }

    // Store other lines
    if (!isDisabled) {
      config.otherLines.push(trimmedLine)
    } else {
      // If it's a disabled line that wasn't matched as export/alias,
      // store it with the #[DISABLED] prefix
      config.otherLines.push(`#[DISABLED] ${trimmedLine}`)
    }
}

/**
 * Convert structured config back to .zshrc format
 */
export function stringifyZshConfig(config: ZshConfig): string {
  const lines: string[] = []

  // Add header comment
  lines.push('# Zsh Configuration')
  lines.push('# Generated by Rei Config Manager')
  lines.push('')

  // Environment variables
  if (Object.keys(config.environmentVariables).length > 0) {
    lines.push('# Environment Variables')
    for (const [key, valueOrInfo] of Object.entries(config.environmentVariables)) {
      if (typeof valueOrInfo === 'string') {
        lines.push(`export ${key}="${escapeValue(valueOrInfo)}"`)
      } else {
        // Include suffix if present
        const line = `export ${key}="${escapeValue(valueOrInfo.value)}"${valueOrInfo.suffix || ''}`
        // Add #[DISABLED] marker if variable is disabled
        if (valueOrInfo.disabled) {
          lines.push(`#[DISABLED] ${line}`)
        } else {
          lines.push(line)
        }
      }
    }
    lines.push('')
  }

  // PATH configuration
  if (config.paths.length > 0) {
    lines.push('# PATH Configuration')
    const pathAdditions = config.paths.join(':')
    lines.push(`export PATH="${pathAdditions}:$PATH"`)
    lines.push('')
  }

  // Aliases
  if (Object.keys(config.aliases).length > 0) {
    lines.push('# Aliases')
    for (const [name, commandOrInfo] of Object.entries(config.aliases)) {
      if (typeof commandOrInfo === 'string') {
        lines.push(`alias ${name}="${escapeValue(commandOrInfo)}"`)
      } else {
        // Include suffix if present
        const line = `alias ${name}="${escapeValue(commandOrInfo.value)}"${commandOrInfo.suffix || ''}`
        // Add #[DISABLED] marker if alias is disabled
        if (commandOrInfo.disabled) {
          lines.push(`#[DISABLED] ${line}`)
        } else {
          lines.push(line)
        }
      }
    }
    lines.push('')
  }

  // Other lines (with deduplication and filtering of generated comments)
  if (config.otherLines.length > 0) {
    lines.push('# Other Configurations')
    const seen = new Set<string>()
    for (const line of config.otherLines) {
      const trimmed = line.trim()
      // Skip duplicates and generated comments
      if (!seen.has(trimmed) && !isGeneratedComment(trimmed)) {
        lines.push(line)
        seen.add(trimmed)
      }
    }
  }

  return lines.join('\n')
}

/**
 * Remove quotes from a value
 */
function unquote(value: string): string {
  value = value.trim()
  if ((value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))) {
    return value.slice(1, -1)
  }
  return value
}

/**
 * Escape special characters in a value for shell
 */
function escapeValue(value: string): string {
  // Only escape double quotes, not dollar signs
  // Dollar signs are already properly escaped in the input
  return value.replace(/"/g, '\\"')
}